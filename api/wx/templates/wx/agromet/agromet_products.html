{% extends "base.html" %} {% block content %} {% load static %} {% load material_form %}

<div class="srf-container">
	<div class="srf-flex flex-row align-items-center justify-content-between srf-padding">
		<span class="srf-display-1 text-uppercase">Agromet Products</span><br /><br />
	</div>
	<div class="srf-flex justify-content-between srf-padding" id="app">
		<v-app>
			<v-overlay :value="loading_data">
				<v-card flat light style="background-color: transparent;">
					<v-card-title class="text-center"> Loading Data... </v-card-title>
					<v-card-actions class="text-center justify-center">
					  <v-progress-circular indeterminate color="primary"/>
					</v-card-actions>
				</v-card>
			</v-overlay>

			<v-form ref="form" v-model="isFormValid" enctype="multipart/form-data" method="POST" class="mb-10">
				{% csrf_token %}
				<v-row>
					<v-col cols="2" class="d-flex justify-left">
						<v-switch 
							v-model="filters.is_automatic"
							:label='filters.is_automatic?"Automatic Stations":"Manual Stations"'
							inset
						/>
					</v-col>
					<v-col cols="4">
						<v-autocomplete
							label="Select Station"
							:items="filteredStationList"
							item-value="id"
							item-text="name"
							v-model="requestData.stationId"
							hint="*Required"
							persistent-hint
							:rules="[rules.required]"
						/>
					</v-col>
                    <v-col cols="3">
                        <v-autocomplete
							label="Select Element"
							:items="Object.keys(elements)"
							v-model="requestData.element"
							required
							hint="*Required"
							persistent-hint
						/>
                    </v-col>
					<v-col cols="2">
                        <v-autocomplete
							label="Select Product"
							:items="Object.keys(elements[requestData.element])"
							v-model="requestData.product"
							required
							hint="*Required"
							persistent-hint
						/>
					</v-col>
				</v-row>
				<v-row>
					<v-col cols="2" v-if="parameterLabels.numericParam1">
						<v-text-field
							v-model="requestData.numericParam1"
							:rules="[rules.required, rules.numeric]"
							:label="parameterLabels.numericParam1"
						/>
					</v-col>
					<v-col cols="2" v-if="parameterLabels.numericParam2">
						<v-text-field
							v-model="requestData.numericParam2"
							:rules="[rules.required, rules.numeric]"
							:label="parameterLabels.numericParam2"
						/>
					</v-col>				
				</v-row>
				<v-row>
					<v-col cols="2">
						<v-autocomplete
							label="Select Start Year"
							:items="availableStartYears"
							v-model="requestData.startYear"
							hint="*Required"
							persistent-hint
							:rules="[rules.required]"
						/>
					</v-col>	
					<v-col cols="2">
						<v-autocomplete
							label="Select End Year"
							:items="availableEndYears"
							v-model="requestData.endYear"
							hint="*Required"
							persistent-hint
							:disabled="!requestData.startYear"
							:rules="[rules.required]"

						/>
					</v-col>
					<v-col cols="3" class="d-flex justify-center">
						<v-switch
							v-model="filters.is_seasonal"
							:label='filters.is_seasonal?"Seasonal Summary":"Monthly Summary"'
							inset
					  	/> 						  
					</v-col>
					<v-col cols="3" v-if="!filters.is_seasonal">
						<v-autocomplete
							label="Select Months"
							:items="months"
							item-value='id'
							item-text="name"
							v-model="requestData.months"
							hint="*Required"
							persistent-hint
							multiple
							clearable
							chips
							deletable-chips
							:rules="[rules.required, rules.nonEmpty]"
						/>
					</v-col>					
					<v-col cols="2" v-if="!filters.is_seasonal">
						<v-autocomplete
							label="Select Interval"
							:items="intervals"
							v-model="requestData.interval"
							:rules="[rules.required]"
							hint="*Required"
							persistent-hint
						/>
					</v-col>
				</v-row>
				<v-row>
					<v-col cols="3" class="d-flex justify-left">
						<v-row>
							<v-col cols="auto" class="d-flex align-center">
							  <v-switch
								v-model="requestData.validateData"
								:label="requestData.validateData ? 'Validate Data' : 'All Data'"
								inset
							  />
							</v-col>
							<v-col cols="auto" class="d-flex align-center">
							  <v-btn icon @click="showing_info=!showing_info"> <v-icon>mdi-information</v-icon> </v-btn>
							</v-col>
						</v-row>
					</v-col>
					<v-col cols="3" v-if="requestData.validateData">
						<v-text-field
							v-model="requestData.maxHourPct"
							:rules="[rules.required, rules.numeric, rules.percentage]"
							label="Maximum Hour Percentage"
							hint="*Required"
							persistent-hint
						/>
					</v-col>
					<v-col cols="3" v-if="requestData.validateData">
						<v-text-field
							v-model="requestData.maxDayPct"
							:rules="[rules.required, rules.numeric, rules.percentage]"
							label="Maximum Day Percentage"
							hint="*Required"
							persistent-hint
						/>
					</v-col>					
					<v-col cols="3" v-if="requestData.validateData">
						<v-text-field
							v-model="requestData.maxDayGap"
							:rules="[rules.required, rules.numeric, rules.positive]"
							label="Maximum Day Gap"
							hint="*Required"
							persistent-hint
						/>
					</v-col>
				</v-row>
				<v-row>
					<v-col cols="12">
						<v-alert
							v-if="showing_info"
							type="info"
							text
							:dismissible="true"
							outlined
							@input="showing_info = false"
						>
							Data validation works as follows:
							The first parameter defines the maximum allowable percentage
							of missing data in the hourly summary to compute a valid day.
							The second parameter sets the maximum percentage of missing 
							valid days for a valid aggregation;
							if exceeded, the aggregation returns null for that partition.
							The third parameter specifies the maximum gap between consecutive days;
							if the gap exceeds this limit,
							the aggregation returns null for that partition.
					  	</v-alert>					
					</v-col>
				</v-row>				
				<v-row>				
					<v-col cols="2" class="d-flex justify-left">
						<v-btn @click="getData" :disabled="!isFormValid"> 
							Request Data
							<v-icon right>send</v-icon>
						</v-btn>
					</v-col
				</v-row>					
			</v-form>
			
			<div>				
				<template>
					<v-card v-if="requestedData.responseData && !loading_data">
						<v-card-title class="text-center"> [[ requestedData.product ]] </v-card-title>
						<v-card-text>
							<template>
								<v-data-table
									:headers="dataTable.headers"
									:items="dataTable.data"
									:items-per-page="-1"
								>
									<template v-for="header in dataTable.colorHeaders" v-slot:[`item.${header.value}`]="{ item }">
											<span :style="{ color: getColor(header, item) }">
												[[ item[header.value] ]]
											</span>
								 	 </template>						  
								</v-data-table>
							</template>
						</v-card-text>
						<v-card-actions>
							<v-btn @click="downloadCSV">
								Download CSV 
								<v-icon right>download</v-icon>
							</v-btn>
						</v-card-actions
					</v-card>					
				</template>	
			</div>			
		</v-app>
	</div>
</div>

{% endblock %} {% block localjavascript %}
 
<script>
	Vue.use(window.vuelidate.default);
	const { required, numeric } = window.validators;

	new Vue({
		el: "#app",
		vuetify: new Vuetify(),
		delimiters: ["[[", "]]"],
		data: {
			now: moment().format('YYYY-MM-DD'),
			username: '{{username | safe}}',
			rules: {
				required: value => !!value || 'Required.',
				nonEmpty: value => !!value && value.length>0 || 'Select at least one item.',
				numeric: value => (!isNaN(value) ) || 'Parameter must be a Numeric.',
				integer: value => (Number.isInteger(value) ) || 'Number must be an integer.',
				percentage: value => (0 <= value && value <= 100) || 'Value must be between 0 and 100.',
				positive: value => (0 <= value) || 'Value must greater than 0.',
			},	
			loading_data: false,
			showing_info: false,
			isFormValid: false,
			requestData: {
				stationId: 4,
                element: 'Relative Humidity',
				product: null,
				numericParam1: null,
				numericParam2: null,
				startYear: 2021,
				endYear: 2025,
				summaryType: 'Seasonal',
				months: [],
				interavl: null,
				validateData: true,
				maxHourPct: 80,
				maxDayPct: 80,
				maxDayGap: 5,
			},
			requestedData: {
				stationId: null,
                element: null,
				product: null,
				numericParam1: null,
				numericParam2: null,
				startYear: null,
				endYear: null,
				responseData: null,
				summaryType: 'Seasonal',
				months: [],
				interavl: null,				
				validateData: false,
				maxHourPct: 0,
				maxDayPct: 0,
				maxDayGap: 0,
			},
			filters: {
				is_automatic: false,
				is_seasonal: true
			},			
			elements: {
				'Air Temperature': {
					'Degree days': {
						'numeric_param_1': {
							value: 30,
							label: 'Base Temperature',
						},
						'numeric_param_2': {
							value: 45,
							label: 'Upper Threshold',
						},
					},
					'Maximum and minimum statistics': {},
					'Hours or days above or below selected temperature': {
						'numeric_param_1': {
							value: 30,
							label: 'Threshold temperature',
						},
					},
					'Growing season statistics': {},
					'Heat wave': {
						'numeric_param_1': {
							value: 30,
							label: 'Threshold temperature',
						},
						'numeric_param_2': {
							value: 5,
							label: 'Heat wave window (days)',
						},
					},
				},
			   'Rainfall': {
					'Number of days with specified amount of rainfall': {
						'numeric_param_1': {
							value: 5,
							label: 'Amount of rainfall',
						},
					},
					'Drought indices ': {},
					'Flood and excess rainfall': {},
			   },
				'Wind': {
					'Wind Rose': {},
					'Maximum Wind and Average Wind speed': {},
					'Diurnal variation': {},
					'Hours of wind less than a selected speed': {
						'numeric_param_1': {
							value: 10,
							label: 'Threshold speed',
						},
					},
				},
				'Sunshine/Radiation':{
					'Amounts of global and net radiation': {},
					'Sunshine and radiation hours': {},
				},
				'Relative Humidity': {
					'Duration of a specified threshold of humidity': {
						'numeric_param_1': {
							value: 80,
							label: 'Threshold humidity',
						},
					},
				},
				'Free Water Evaporation / Evapotranspiration': {
					'Total amount': {},
					'Diurnal variation of evaporation': {},
					'Evapotranspiration': {},
				},
				'Soil Temperature':{
					'Mean and standard deviation at standard depth;': {},
					'Dates when threshold values of temperature (germination, vegetation) are reached.': {},
					'Soil Moisture': {},
					'Soil Moisture at regular depths': {},
					'Leaf area index': {},
				}
			},
			parameterLabels: {
				numericParam1: null,
				numericParam2: null,
			},
			start_year_menu: false,
			end_year_menu: false,
			intervals: ['7 days', '10 days', '1 month'],
			months: [
				{id: 1, name: 'Jan'},
				{id: 2, name: 'Feb'},
				{id: 3, name: 'Mar'},
				{id: 4, name: 'Apr'},
				{id: 5, name: 'May'},
				{id: 6, name: 'Jun'},
				{id: 7, name: 'Jul'},
				{id: 8, name: 'Aug'},
				{id: 9, name: 'Sep'},
				{id: 10, name: 'Oct'},
				{id: 11, name: 'Nov'},
				{id: 12, name: 'Dec'},
			],
			stationList: [
				{% for station in station_list %}
					{
						id: {{station.id}},
						base_name: "{{station.name | safe }}",
						name: "{{station.name | safe }} - {{station.code}}",
						is_automatic:  {{station.is_automatic|yesno:"true,false"}},
						latitude: {{station.latitude}},
						longitude: {{station.longitude}}
					},
				{% endfor %}
			]
		},
		watch: {
			'requestData.startYear' (newStartYear, oldStartYear) {
				this.requestData.endYear = null
			},
			'filters.is_automatic' (newValue, oldValue) {
				this.requestData.stationId = null
			},
			'filters.is_seasonal' (newValue, oldValue) {
				this.requestData.summaryType = newValue?'Seasonal':'Monthly'
			},
			'requestData.element' (newElement, oldElement){
				this.requestData.product = null
			},
			'requestData.product' (newProduct, oldProduct){
				const { element, product, ...rest } = this.requestData;
				if (this.requestData.product) {
					this.requestData.numericParam1 = this.elements[element][product].numeric_param_1?.value || null
					this.requestData.numericParam2 = this.elements[element][product].numeric_param_2?.value || null

					this.parameterLabels.numericParam1 = this.elements[element][product].numeric_param_1?.label || null
					this.parameterLabels.numericParam2 = this.elements[element][product].numeric_param_2?.label || null
				}
				else {
					this.requestData.numericParam1 = null
					this.requestData.numericParam2 = null
					this.parameterLabels.numericParam1 = null
					this.parameterLabels.numericParam2 = null
				}
			},
			'requestData.summaryType' (newSummaryType, oldSummaryType){
				this.requestData.months = []
			},
		},	
		computed: {		
			availableStartYears () {
				const min_year = 1900
				const max_year = moment().year()
				return Array.from({ length: max_year - min_year + 1 }, (_, i) => max_year - i);
			},
			availableEndYears () {
				if (!this.requestData.startYear) return [];
				const min_year = this.requestData.startYear
				const max_year = moment().year()
				return Array.from({ length: max_year - min_year + 1 }, (_, i) => max_year - i);
			},			
			filteredStationList() {
				return this.stationList.filter(station=>station.is_automatic===this.filters.is_automatic)
			},
			dataTable () {
				let filteredData = this.requestedData.responseData

				let baseKeys = []
				let baseHeaders = []

				if (this.requestedData.summaryType==='Seasonal'){
					baseKeys = ['station', 'year']
					baseHeaders = [{ text: 'Year', align: 'end', value: 'year', sortable: false}];
					
				}
				else if (this.requestedData.summaryType==='Monthly'){
					baseHeaders = [
						{ text: 'Year', align: 'end', value: 'year', sortable: false},
						{ text: 'Month', align: 'end', value: 'month', sortable: false}
					];
					baseKeys = ['station', 'year', 'month']
				}

				const keys = filteredData.length? Object.keys(filteredData[0]).filter(item => !baseKeys.includes(item)): [];
				const calcHeaders = keys.map(item => ({text: item, align: 'end', value: item, sortable: false}));

				const colorHeaders = calcHeaders.filter(item => !item.value.endsWith('(% of days)'));
				
				return { headers: [...baseHeaders, ...calcHeaders], data: filteredData, colorHeaders: colorHeaders};		
			},
			filteredMinMaxData () {
				const station = this.stationList.find(station => station.id === this.requestedData.stationId)
				return this.requestedData.responseMinMaxData[station.base_name]
			}			
		},
		methods: {
            getData(){
				this.loading_data = true


				this.requestedData.stationId = this.requestData.stationId
				this.requestedData.element = this.requestData.element
				this.requestedData.product = this.requestData.product				
				this.requestedData.numericParam1 = this.requestData.numericParam1
				this.requestedData.numericParam2 = this.requestData.numericParam2
				this.requestedData.startYear = this.requestData.startYear
				this.requestedData.endYear = this.requestData.endYear
				this.requestedData.summaryType = this.requestData.summaryType
				this.requestedData.months = this.requestData.months
				this.requestedData.interval = this.requestData.interval
				this.requestedData.validateData = this.requestData.validateData
				this.requestedData.maxHourPct = this.requestData.maxHourPct
				this.requestedData.maxDayPct = this.requestData.maxDayPct
				this.requestedData.maxDayGap = this.requestData.maxDayGap
				this.requestedData.responseData = null
				this.requestedData.responseMinMaxData = null
				this.requestedData.requestedAt = moment().format('YYYY-MM-DD HH:mm')

				const url = `/wx/agromet/products/get/`

				const params = {
					station_id: this.requestedData.stationId,
					element: this.requestedData.element,
					product: this.requestedData.product,
					numeric_param_1: this.requestedData.numericParam1,
					numeric_param_2: this.requestedData.numericParam2,
					start_year: this.requestedData.startYear,
					end_year: this.requestedData.endYear,
					summary_type: this.requestedData.summaryType,
					months: this.requestedData.months,
					interval: this.requestedData.interval,
					validate_data: this.requestedData.validateData,
					max_hour_pct: this.requestedData.maxHourPct,
					max_day_pct: this.requestedData.maxDayPct,
					max_day_gap: this.requestedData.maxDayGap
				};

        		axios.get(url, { params })
				.then(response => {
					this.requestedData.responseData = response.data.tableData;
					this.requestedData.responseMinMaxData = response.data.minMaxData;
				})
				.catch(error => {
					console.error('Error fetching data:', error);
				})
				.finally(() => {
					this.loading_data = false
				});
			},
			convertToCSV(data) {
				const { stationId, element, product, summaryType, startYear, endYear, interval, requestedAt, months, ...rest } = this.requestedData;
				
				const station = this.stationList.find(station => station.id === stationId)

				const metadataList = [
					`Description: Agromet ${summaryType} Summary\n`,
					`Station Name: ${station?.name}\n`,
					`Element: ${element}\n`,
					`Product: ${product}\n`,
					`${summaryType === 'Monthly' ? `Interval: ${interval}\nMonths: ${months}\n` : ''}`,
					`Start/End Year: ${startYear}/${endYear}\n`,
					`Station Lat/Lon: ${station?.latitude}/${station?.longitude}\n`,
					`Request Datetime: ${requestedAt}\n`,
					`UserName: ${this.username}`
				]

				const metadata = `"`+metadataList.join('')+`"\n\n`
			  
				const headers = data.headers.map(item => item.text).join(',') + '\n';

				const indicesToRemove = [0] // Exclude the StationID column
				const rows = data.data.map(row => 
				  Object.values(row)
					.filter((value, index) => !indicesToRemove.includes(index)) 
					.map(value => `"${value}"`)
					.join(',')
				).join('\n');

				return metadata + headers + rows;
			},
			downloadCSV() {
				const csvContent = this.convertToCSV(this.dataTable);
				const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
				const link = document.createElement('a');

				const { stationId, element, product, summaryType, startYear, endYear, interval, ...rest } = this.requestedData;

				const station = this.stationList.find(station => station.id === stationId)
						
				const filename = summaryType === 'Monthly' 
  					? `agromet-summary-(${summaryType})-${station?.name}-${element}-${product}-${startYear}-${endYear}-[${interval}].csv`
  					: `agromet-summary-(${summaryType})-${station?.name}-${element}-${product}-${startYear}-${endYear}.csv`;
			
				link.href = URL.createObjectURL(blob);
				link.download = filename;
				link.style.visibility = 'hidden';
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			},
			getColor (header, item) {
				const station = this.stationList.find(station => station.id === this.requestedData.stationId)
				let filteredMinMaxData = this.requestedData.responseMinMaxData[station.base_name]

				if (Object.keys(filteredMinMaxData).length === 0) return 'black'

				let item_entry = (this.requestedData.summaryType === 'Monthly')? {month: item.month, year: item.year} : {year: item.year}

				const is_min = filteredMinMaxData[header.value].min.some(item => JSON.stringify(item) === JSON.stringify(item_entry));
				const is_max = filteredMinMaxData[header.value].max.some(item => JSON.stringify(item) === JSON.stringify(item_entry));

				if (is_min && is_max) return 'black'
				else if (is_min) return 'blue'
				else if (is_max) return 'red'
				return 'black'
			},					
		}		
	})
</script>
{% endblock %}
